{"version":3,"sources":["../../../../../Downloads/wall-street-playbook/lib/rate-limit.ts"],"sourcesContent":["/**\n * Simple in-memory rate limiter for API routes.\n * Uses a sliding window approach with automatic cleanup.\n *\n * Note: In a multi-instance deployment (e.g., multiple Vercel serverless functions),\n * each instance maintains its own store. For stricter enforcement, consider\n * using @upstash/ratelimit with Redis. This is still effective at reducing\n * abuse since most requests hit the same instance within the window.\n */\n\ninterface RateLimitEntry {\n  count: number\n  resetAt: number\n}\n\nconst store = new Map<string, RateLimitEntry>()\n\n// Clean up expired entries every 5 minutes\nconst CLEANUP_INTERVAL = 5 * 60 * 1000\nlet lastCleanup = Date.now()\n\nfunction cleanup() {\n  const now = Date.now()\n  if (now - lastCleanup < CLEANUP_INTERVAL) return\n  lastCleanup = now\n\n  for (const [key, entry] of store) {\n    if (now > entry.resetAt) {\n      store.delete(key)\n    }\n  }\n}\n\ninterface RateLimitOptions {\n  /** Maximum number of requests allowed within the window */\n  maxRequests: number\n  /** Time window in seconds */\n  windowSeconds: number\n}\n\ninterface RateLimitResult {\n  success: boolean\n  remaining: number\n  resetAt: number\n}\n\n/**\n * Check if a request should be rate-limited.\n *\n * @param identifier - Unique identifier for the client (e.g., IP address)\n * @param options - Rate limit configuration\n * @returns Whether the request is allowed\n */\nexport function rateLimit(\n  identifier: string,\n  options: RateLimitOptions\n): RateLimitResult {\n  cleanup()\n\n  const now = Date.now()\n  const windowMs = options.windowSeconds * 1000\n  const key = identifier\n\n  const entry = store.get(key)\n\n  if (!entry || now > entry.resetAt) {\n    // First request or window expired\n    store.set(key, {\n      count: 1,\n      resetAt: now + windowMs,\n    })\n    return {\n      success: true,\n      remaining: options.maxRequests - 1,\n      resetAt: now + windowMs,\n    }\n  }\n\n  if (entry.count >= options.maxRequests) {\n    return {\n      success: false,\n      remaining: 0,\n      resetAt: entry.resetAt,\n    }\n  }\n\n  entry.count++\n  return {\n    success: true,\n    remaining: options.maxRequests - entry.count,\n    resetAt: entry.resetAt,\n  }\n}\n\n/**\n * Extract a client identifier from the request.\n * Uses X-Forwarded-For (set by Vercel/proxies) or falls back to a default.\n */\nexport function getClientIp(request: Request): string {\n  const forwarded = request.headers.get('x-forwarded-for')\n  if (forwarded) {\n    return forwarded.split(',')[0].trim()\n  }\n  // Fallback â€” all requests from unknown IPs share a bucket\n  return 'unknown'\n}\n"],"names":[],"mappings":"i3CAeA,IAAM,EAAQ,IAAI,IAId,EAAc,KAAK,GAAG,GAkCnB,SAAS,EACd,CAAkB,CAClB,CAAyB,EAjCzB,IAAM,EAAM,KAAK,GAAG,GACpB,KAAI,EAAM,EALa,GAKC,CALG,CAQ3B,CAH0C,GAGrC,AAR2B,GAQrB,AAHa,CAGZ,EAAK,EAAM,GAFvB,EAAc,EAEa,GACrB,EAAM,CADsB,CAChB,OAAO,EAAE,AACvB,EAAM,MAAM,CAAC,GA+BjB,IAAM,EAAM,KAAK,GAAG,GACd,EAAmC,IAAxB,EAAQ,aAAa,CAGhC,EAAQ,EAAM,GAAG,CAAC,SAExB,AAAI,CAAC,GAAS,EAAM,EAAM,OAAO,EAAE,AAEjC,EAAM,GAAG,CAAC,AANA,EAMK,CACb,MAAO,EACP,QAAS,EAAM,CACjB,GACO,CACL,SAAS,EACT,UAAW,EAAQ,WAAW,CAAG,EACjC,QAAS,EAAM,CACjB,GAGE,EAAM,KAAK,EAAI,EAAQ,WAAW,CAC7B,CACL,AAFoC,SAE3B,EACT,UAAW,EACX,QAAS,EAAM,OAAO,AACxB,GAGF,EAAM,KAAK,GACJ,CACL,SAAS,EACT,UAAW,EAAQ,WAAW,CAAG,EAAM,KAAK,CAC5C,QAAS,EAAM,OAAO,AACxB,EACF,CAMO,SAAS,EAAY,CAAgB,EAC1C,IAAM,EAAY,EAAQ,OAAO,CAAC,GAAG,CAAC,0BACtC,AAAI,EACK,EAAU,KAAK,CAAC,CADV,GACc,CAAC,EAAE,CAAC,IAAI,GAG9B,SACT"}